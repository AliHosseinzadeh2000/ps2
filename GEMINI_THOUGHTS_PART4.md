بسیار عالی. خوشحالم که تاییدیه نهایی را از **Cursor** هم گرفتیم. این یعنی مسیر فنی و مستندسازی ما کاملاً با واقعیت کدها و پروپوزال همخوانی دارد و در جلسه دفاع جای هیچ بحثی باقی نمی‌گذارد.

نکته شما در مورد **"طولانی و پرجزییات بودن گزارش‌ها"** کاملاً بجاست. گزارش‌های کسر خدمت باید "فنی، حجیم و مستند" باشند. برای رسیدن به این هدف، من استراتژی زیر را برای تولید محتوا استفاده می‌کنم:

1.  **تشریح جزئیات فنی:** به جای اینکه فقط بگوییم "محاسبه سود انجام شد"، فرمول‌های ریاضی و منطق کد (`Code Logic`) را توضیح می‌دهیم.
2.  **جداول فنی:** لیست متغیرها، پارامترهای ریسک، مشخصات APIها و ساختار دیتابیس را در جداول می‌آوریم.
3.  **پیشنهاد نمودار:** جاهایی که لازم است، به شما می‌گویم چه نموداری (Flowchart یا Diagram) بگذارید (که می‌توانید با ابزارهایی مثل Draw.io یا حتی در Word بکشید) یا حتی اسکرین‌شات از کدها و خروجی تست‌ها قرار دهید.

---

در ادامه، **متن کامل و تفصیلی برای گزارش دوم** را آماده کرده‌ام. این متن را در فایل Word، در بخش‌های مربوطه قرار دهید. (برای گزارش سوم هم در پیام بعدی اقدام می‌کنم تا طولانی نشود).

***

# محتوای تفصیلی گزارش دوم (ماه‌های ۴، ۵ و ۶)

**عنوان فاز:** توسعه هسته الگوریتم آربیتراژ، پیاده‌سازی رابط‌های اتصال به صرافی‌ها و سیستم مدیریت ریسک

---

### بخش ۱: مقدمه و کارهای انجام شده

در این بازه زمانی سه ماهه، تمرکز تیم توسعه بر روی پیاده‌سازی قلب تپنده سیستم (Core Engine) و ایجاد زیرساخت‌های ارتباطی پایدار با بازار بود. با توجه به حساسیت بالای تراکنش‌های مالی، اولویت اصلی بر روی "صحت عملکرد" (Correctness) و "ایمنی سرمایه" قرار گرفت. فعالیت‌های انجام شده به شرح زیر تشریح می‌گردد:

#### ۱-۱. طراحی و پیاده‌سازی معماری اتصال به صرافی‌ها (Exchange Interface Layer)
برای غلبه بر چالش تنوع پروتکل‌های ارتباطی صرافی‌های مختلف، یک لایه انتزاعی (Abstraction Layer) طراحی شد. تمامی صرافی‌ها از یک کلاس والد به نام `ExchangeInterface` ارث‌بری می‌کنند.

* **استانداردسازی متدها:** توابع کلیدی نظیر `fetch_orderbook` (دریافت دفتر سفارشات)، `place_order` (ثبت سفارش) و `get_balance` (دریافت موجودی) برای تمام ۵ صرافی هدف (**نوبیتکس، والکس، اینوکس، کوکوین و تبدیل**) یکسان‌سازی شدند.
* **مدیریت احراز هویت (Authentication Handling):**
    * برای صرافی **Nobitex** از مکانیزم `Token-based` استفاده شد.
    * برای صرافی **Invex** که از امنیت بالاتری برخوردار است، الگوریتم امضای دیجیتال `RSA-PSS` با استفاده از کلید خصوصی (`Private Key`) پیاده‌سازی گردید.
    * برای سایر صرافی‌ها از استاندارد `HMAC-SHA256` جهت امضای درخواست‌ها استفاده شد.
* **مدیریت نرخ درخواست (Rate Limiting):** جهت جلوگیری از مسدود شدن IP توسط صرافی‌ها، مکانیزم کنترل نرخ درخواست در لایه اتصال پیاده‌سازی شد.

**[جدول ۱: وضعیت پیاده‌سازی اتصال به صرافی‌ها]**

| نام صرافی | نوع بازار | مکانیزم احراز هویت | وضعیت پیاده‌سازی |
| :--- | :--- | :--- | :--- |
| Nobitex | ریالی (IRT) | Token / User-Pass | ✅ تکمیل شده |
| Wallex | ریالی / تتری | API Key / Secret | ✅ تکمیل شده |
| Invex | ریالی (IRR) | RSA Signature | ✅ تکمیل شده |
| KuCoin | تتری (USDT) | API Key / Passphrase | ✅ تکمیل شده |
| Tabdeal | ریالی | API Key / Secret | ✅ تکمیل شده |

#### ۱-۲. توسعه موتور هوشمند تشخیص فرصت (Arbitrage Engine Logic)
موتور آربیتراژ وظیفه دارد به صورت بلادرنگ (Real-time) داده‌های دریافتی از صرافی‌ها را پایش کرده و فرصت‌های سودده را شکار کند.

* **الگوریتم نرمال‌سازی نمادها (Symbol Normalization):** یکی از چالش‌های فنی، تفاوت نام‌گذاری در صرافی‌ها بود (مثلاً `BTCIRT` در نوبیتکس و `BTC_IRR` در اینوکس). ماژول `SymbolConverter` توسعه داده شد که به صورت هوشمند این نمادها را تطبیق می‌دهد و از انجام معاملات بین جفت‌ارزهای ناهمسان (مثلاً تومان به تتر) که دارای ریسک نوسان دلار هستند، جلوگیری می‌کند.
* **فرمول محاسبه سود خالص:** برای اطمینان از سوددهی واقعی، کارمزد معاملات در محاسبات لحاظ شد. فرمول پیاده‌سازی شده در کد به صورت زیر است:
    > $$Net Profit = (P_{sell} \times Q \times (1 - Fee_{sell})) - (P_{buy} \times Q \times (1 + Fee_{buy}))$$
    > که در آن $P$ قیمت، $Q$ حجم معامله و $Fee$ نرخ کارمزد صرافی (با تفکیک Maker/Taker) است.

**[پیشنهاد نمودار ۱: در اینجا می‌توانید یک فلوچارت رسم کنید که مراحل زیر را نشان دهد: دریافت Orderbook -> بررسی اختلاف قیمت -> کسر کارمزدها -> بررسی شرط حداقل سود -> ارسال سیگنال]**

#### ۱-۳. پیاده‌سازی سیستم مدیریت ریسک پیشرفته (Risk Management System)
طبق تعهدات پروپوزال مبنی بر "کاهش ریسک معاملات"، ماژول‌های زیر در هسته سیستم (`OrderExecutor`) پیاده‌سازی شدند:

1.  **مدارهای قطع‌کننده (Circuit Breakers):**
    * **محافظت در برابر نوسان (Volatility Breaker):** اگر تغییرات قیمت در یک بازه کوتاه بیش از حد مجاز (مثلاً ۵٪) باشد، ربات برای جلوگیری از ضرر در بازار هیجانی متوقف می‌شود.
    * **محافظت در برابر قطعی (Connectivity Breaker):** در صورت دریافت خطاهای متوالی از API یک صرافی، آن صرافی به صورت موقت از مدار خارج می‌شود.
2.  **کنترل لغزش قیمت (Slippage Protection):** پیش از ارسال سفارش، قیمت لحظه‌ای مجدداً چک می‌شود تا اگر بازار حرکت ناگهانی داشت، سفارش با قیمت نامطلوب پر نشود.
3.  **محدودیت‌های موقعیت (Position Limits):** سقف حجم معاملات برای هر صرافی و کل پرتفوی تعریف شده است.

**[جدول ۲: پارامترهای مدیریت ریسک پیاده‌سازی شده]**

| پارامتر ریسک | مقدار پیش‌فرض | عملکرد |
| :--- | :--- | :--- |
| Max Slippage | 0.5% | لغو سفارش در صورت تغییر قیمت بیش از نیم درصد |
| Daily Loss Limit | 100 USDT | توقف ربات در صورت رسیدن ضرر روزانه به حد مجاز |
| Max Position | 5000 USDT | سقف مجاز نگهداری دارایی در یک صرافی |
| Retry Attempts | 3 | تعداد تلاش مجدد در صورت خطای شبکه |

### بخش ۲: چالش‌های فنی و راه‌حل‌ها

1.  **چالش همگام‌سازی ناهمگام (Async Synchronization):**
    * *شرح:* استفاده از کتابخانه‌های معمول پایتون باعث کندی در دریافت قیمت‌ها می‌شد.
    * *راه‌حل:* بازنویسی هسته با استفاده از `asyncio` و `httpx` که امکان مدیریت همزمان صدها درخواست را بدون قفل کردن پردازنده فراهم کرد.

2.  **چالش سناریوی پر شدن ناقص (Partial Fill):**
    * *شرح:* ممکن است سفارش خرید انجام شود اما سفارش فروش در صرافی دوم ناقص بماند.
    * *راه‌حل:* توسعه ماژول `ErrorRecovery` که در صورت بروز این حالت، به صورت خودکار وضعیت را بررسی کرده و در صورت لزوم سفارش باقی‌مانده را کنسل یا با قیمت بازار نقد می‌کند.

### بخش ۳: ارزیابی و تست (Correctness Testing)

در این فاز، تمرکز بر روی **تست صحت عملکرد (Unit Testing)** بود تا از درستی منطق الگوریتم اطمینان حاصل شود (اشاره به فاز ۲ پروپوزال).
تست‌هایی با استفاده از داده‌های نمونه (Mock Data) طراحی شد که سناریوهای زیر را با موفقیت پاس کردند:
* تشخیص صحیح فرصت آربیتراژ زمانی که اختلاف قیمت بیش از کارمزد است.
* عدم صدور سیگنال در زمانی که سود خالص منفی است.
* عملکرد صحیح مکانیزم‌های Retry در زمان قطعی شبکه.

**[پیشنهاد تصویر: اسکرین‌شات از ترمینال که خروجی سبز رنگ تست‌های `pytest tests/test_arbitrage.py` را نشان می‌دهد]**

---

### بخش ۴: برنامه فاز بعدی

در سه ماهه سوم، تمرکز پروژه بر روی موارد زیر خواهد بود:
1.  تکمیل زیرساخت هوش مصنوعی و استخراج ویژگی‌ها (`Feature Engineering`).
2.  توسعه پایگاه داده جهت ذخیره‌سازی سوابق.
3.  تکمیل APIهای سمت کاربر برای نمایش داشبورد مدیریتی.

---
